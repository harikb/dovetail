package action

import (
	"fmt"
	"io"
	"sort"
	"time"

	"github.com/harikb/dovetail/internal/compare"
	"github.com/harikb/dovetail/internal/util"
)

// Generator creates action files from comparison results
type Generator struct {
	version string
}

// NewGenerator creates a new action file generator
func NewGenerator(version string) *Generator {
	return &Generator{
		version: version,
	}
}

// GenerateActionFile creates an action file from comparison results
func (g *Generator) GenerateActionFile(
	writer io.Writer,
	results []compare.ComparisonResult,
	leftDir, rightDir string,
	summary *compare.ComparisonSummary,
	includeIdentical bool,
) error {
	header := ActionFileHeader{
		GeneratedAt: time.Now().Format("2006-01-02 15:04:05"),
		LeftDir:     leftDir,
		RightDir:    rightDir,
		Version:     g.version,
	}

	// Write header
	if err := g.writeHeader(writer, header, summary); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	// Convert comparison results to action items and sort them
	actionItems := g.convertToActionItems(results, includeIdentical)
	sort.Slice(actionItems, func(i, j int) bool {
		return actionItems[i].RelativePath < actionItems[j].RelativePath
	})

	// Write action items
	for _, item := range actionItems {
		if err := g.writeActionItem(writer, item); err != nil {
			return fmt.Errorf("failed to write action item: %w", err)
		}
	}

	return nil
}

// writeHeader writes the action file header with metadata and instructions
func (g *Generator) writeHeader(writer io.Writer, header ActionFileHeader, summary *compare.ComparisonSummary) error {
	lines := []string{
		fmt.Sprintf("# Action File generated on %s", header.GeneratedAt),
		fmt.Sprintf("# Generated by dovetail version %s", header.Version),
		fmt.Sprintf("# Left:  %s", header.LeftDir),
		fmt.Sprintf("# Right: %s", header.RightDir),
		"#",
		"# INSTRUCTIONS:",
		"# Edit the [ACTION] for each file to specify what you want to do.",
		"# By default, all actions are set to [i] (ignore) to prevent accidents.",
		"#",
		"# Available Actions:",
		fmt.Sprintf("#   %-3s : %s", ActionIgnore.String(), ActionIgnore.Description()),
		fmt.Sprintf("#   %-3s : %s", ActionCopyToRight.String(), ActionCopyToRight.Description()),
		fmt.Sprintf("#   %-3s : %s", ActionCopyToLeft.String(), ActionCopyToLeft.Description()),
		fmt.Sprintf("#   %-3s : %s", ActionDeleteLeft.String(), ActionDeleteLeft.Description()),
		fmt.Sprintf("#   %-3s : %s", ActionDeleteRight.String(), ActionDeleteRight.Description()),
		fmt.Sprintf("#   %-3s : %s", ActionDeleteBoth.String(), ActionDeleteBoth.Description()),
		"#",
		"# COMPARISON SUMMARY:",
	}

	if summary != nil {
		lines = append(lines,
			fmt.Sprintf("#   Files - Total: %d, Identical: %d, Modified: %d, Left only: %d, Right only: %d",
				summary.TotalFiles, summary.IdenticalFiles, summary.ModifiedFiles, summary.OnlyLeftFiles, summary.OnlyRightFiles),
			fmt.Sprintf("#   Dirs  - Total: %d, Identical: %d, Left only: %d, Right only: %d",
				summary.TotalDirs, summary.IdenticalDirs, summary.OnlyLeftDirs, summary.OnlyRightDirs),
		)

		if len(summary.ErrorsEncountered) > 0 {
			lines = append(lines, fmt.Sprintf("#   Errors: %d (see details below)", len(summary.ErrorsEncountered)))
		}
	}

	lines = append(lines,
		"#",
		"# FORMAT: [ACTION] : STATUS : RELATIVE_PATH",
		"#",
	)

	// Add error details if any
	if summary != nil && len(summary.ErrorsEncountered) > 0 {
		lines = append(lines, "# ERRORS ENCOUNTERED:")
		for _, err := range summary.ErrorsEncountered {
			lines = append(lines, fmt.Sprintf("# ERROR: %s", err))
		}
		lines = append(lines, "#")
	}

	for _, line := range lines {
		if _, err := fmt.Fprintf(writer, "%s\n", line); err != nil {
			return err
		}
	}

	return nil
}

// convertToActionItems converts comparison results to action items
func (g *Generator) convertToActionItems(results []compare.ComparisonResult, includeIdentical bool) []ActionItem {
	var items []ActionItem

	for _, result := range results {
		// Skip identical files unless explicitly requested
		if result.Status == compare.StatusIdentical && !includeIdentical {
			continue
		}

		item := ActionItem{
			Action:       ActionIgnore, // Default to ignore for safety
			Status:       result.Status,
			RelativePath: result.RelativePath,
			LeftInfo:     result.LeftInfo,
			RightInfo:    result.RightInfo,
		}

		items = append(items, item)
	}

	return items
}

// writeActionItem writes a single action item to the writer
func (g *Generator) writeActionItem(writer io.Writer, item ActionItem) error {
	// Format: [ACTION] : STATUS : RELATIVE_PATH
	line := fmt.Sprintf("[%s] : %-12s : %s",
		item.Action.String(),
		item.Status.String(),
		item.RelativePath,
	)

	// Add size information for files as a comment
	if item.LeftInfo != nil && !item.LeftInfo.IsDir && item.RightInfo != nil && !item.RightInfo.IsDir {
		// Both files exist
		if item.Status == compare.StatusModified {
			line += fmt.Sprintf("  # L:%s R:%s",
				util.FormatSize(item.LeftInfo.Size),
				util.FormatSize(item.RightInfo.Size))
		}
	} else if item.LeftInfo != nil && !item.LeftInfo.IsDir {
		// Only left file exists
		line += fmt.Sprintf("  # Size: %s", util.FormatSize(item.LeftInfo.Size))
	} else if item.RightInfo != nil && !item.RightInfo.IsDir {
		// Only right file exists
		line += fmt.Sprintf("  # Size: %s", util.FormatSize(item.RightInfo.Size))
	}

	if _, err := fmt.Fprintf(writer, "%s\n", line); err != nil {
		return err
	}

	return nil
}
