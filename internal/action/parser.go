package action

import (
	"bufio"
	"fmt"
	"io"
	"regexp"
	"strings"

	"github.com/harikb/dovetail/internal/compare"
)

// Parser parses action files
type Parser struct {
	actionLineRegex *regexp.Regexp
}

// NewParser creates a new action file parser
func NewParser() *Parser {
	// Regex to match action lines: [ACTION] : STATUS : PATH
	actionLineRegex := regexp.MustCompile(`^\[([^\]]+)\]\s*:\s*([^:]+)\s*:\s*(.+)$`)

	return &Parser{
		actionLineRegex: actionLineRegex,
	}
}

// ParseActionFile parses an action file from a reader
func (p *Parser) ParseActionFile(reader io.Reader) (*ActionFile, error) {
	actionFile := &ActionFile{
		Actions:  make([]ActionItem, 0),
		Comments: make([]string, 0),
	}

	scanner := bufio.NewScanner(reader)
	lineNumber := 0

	for scanner.Scan() {
		lineNumber++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines
		if line == "" {
			continue
		}

		// Handle comments and extract header info
		if strings.HasPrefix(line, "#") {
			p.parseHeaderLine(line, &actionFile.Header)
			actionFile.Comments = append(actionFile.Comments, line)
			continue
		}

		// Parse action line
		actionItem, err := p.parseActionLine(line, lineNumber)
		if err != nil {
			return nil, ActionFileError{
				Type:    "parse",
				Line:    lineNumber,
				Message: err.Error(),
				Err:     err,
			}
		}

		if actionItem != nil {
			actionFile.Actions = append(actionFile.Actions, *actionItem)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading action file: %w", err)
	}

	return actionFile, nil
}

// parseHeaderLine extracts information from header comment lines
func (p *Parser) parseHeaderLine(line string, header *ActionFileHeader) {
	line = strings.TrimSpace(line)
	if strings.HasPrefix(line, "# Action File generated on ") {
		header.GeneratedAt = strings.TrimPrefix(line, "# Action File generated on ")
	} else if strings.HasPrefix(line, "# Generated by dovetail version ") {
		header.Version = strings.TrimPrefix(line, "# Generated by dovetail version ")
	} else if strings.HasPrefix(line, "# Left:") {
		header.LeftDir = strings.TrimSpace(strings.TrimPrefix(line, "# Left:"))
	} else if strings.HasPrefix(line, "# Right:") {
		header.RightDir = strings.TrimSpace(strings.TrimPrefix(line, "# Right:"))
	}
}

// parseActionLine parses a single action line
func (p *Parser) parseActionLine(line string, lineNumber int) (*ActionItem, error) {
	// Remove inline comments
	if commentIndex := strings.Index(line, "#"); commentIndex > 0 {
		line = strings.TrimSpace(line[:commentIndex])
	}

	// Match against the regex
	matches := p.actionLineRegex.FindStringSubmatch(line)
	if len(matches) != 4 {
		return nil, fmt.Errorf("invalid action line format: %s", line)
	}

	actionStr := strings.TrimSpace(matches[1])
	statusStr := strings.TrimSpace(matches[2])
	pathStr := strings.TrimSpace(matches[3])

	// Parse action type
	action, valid := ParseActionType(actionStr)
	if !valid {
		return nil, ValidationError{
			LineNumber: lineNumber,
			Message:    fmt.Sprintf("unknown action type: %s", actionStr),
			Action:     actionStr,
		}
	}

	// Parse status
	status, err := p.parseStatus(statusStr)
	if err != nil {
		return nil, ValidationError{
			LineNumber: lineNumber,
			Message:    fmt.Sprintf("unknown status: %s", statusStr),
			Action:     actionStr,
		}
	}

	actionItem := &ActionItem{
		Action:       action,
		Status:       status,
		RelativePath: pathStr,
		LineNumber:   lineNumber,
	}

	return actionItem, nil
}

// parseStatus converts a status string to FileStatus
func (p *Parser) parseStatus(statusStr string) (compare.FileStatus, error) {
	switch strings.TrimSpace(statusStr) {
	case "IDENTICAL":
		return compare.StatusIdentical, nil
	case "MODIFIED":
		return compare.StatusModified, nil
	case "ONLY_IN_LEFT":
		return compare.StatusOnlyLeft, nil
	case "ONLY_IN_RIGHT":
		return compare.StatusOnlyRight, nil
	default:
		return compare.StatusIdentical, fmt.Errorf("unknown status: %s", statusStr)
	}
}

// ValidateActionFile validates the actions in an action file
func (p *Parser) ValidateActionFile(actionFile *ActionFile, leftDir, rightDir string) []ValidationError {
	var errors []ValidationError

	for _, action := range actionFile.Actions {
		validationErrs := p.validateAction(action, leftDir, rightDir)
		errors = append(errors, validationErrs...)
	}

	return errors
}

// validateAction validates a single action for logical consistency
func (p *Parser) validateAction(action ActionItem, leftDir, rightDir string) []ValidationError {
	var errors []ValidationError

	// Check if action makes sense for the status
	switch action.Status {
	case compare.StatusOnlyLeft:
		// File exists only in left
		if action.Action == ActionCopyToLeft || action.Action == ActionDeleteRight {
			errors = append(errors, ValidationError{
				LineNumber: action.LineNumber,
				Message:    "cannot copy to left or delete from right when file only exists in left",
				Action:     action.Action.String(),
			})
		}

	case compare.StatusOnlyRight:
		// File exists only in right
		if action.Action == ActionCopyToRight || action.Action == ActionDeleteLeft {
			errors = append(errors, ValidationError{
				LineNumber: action.LineNumber,
				Message:    "cannot copy to right or delete from left when file only exists in right",
				Action:     action.Action.String(),
			})
		}

	case compare.StatusIdentical:
		// Files are identical
		if action.Action == ActionCopyToRight || action.Action == ActionCopyToLeft {
			// This is not an error, but could be a warning
			// User might want to copy identical files for some reason
		}
	}

	// Additional validations could be added here:
	// - Check if files still exist
	// - Check permissions
	// - Check disk space
	// etc.

	return errors
}
